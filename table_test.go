package aspect

import (
	"fmt"
	"runtime"
	"strings"
	"testing"
)

// Declare schemas that can be used package-wide
var users = Table("users",
	Column("id", Integer{NotNull: true}),
	Column("name", String{Length: 32, NotNull: true}),
	Column("password", String{Length: 128}),
	PrimaryKey("id"),
)

type user struct {
	Id       int64  `db:"id"`
	Name     string `db:"name"`
	Password string `db:"password"`
}

var views = Table("views",
	Column("id", Integer{PrimaryKey: true}),
	Column("user_id", Integer{}),
	Column("url", String{}),
	Column("ip", String{}),
	Column("timestamp", Timestamp{}),
)

var edges = Table("edges",
	Column("a", Integer{}),
	Column("b", Integer{}),
	PrimaryKey("a", "b"),
)

var attrs = Table("attrs",
	Column("id", Integer{PrimaryKey: true}),
	Column("a", Integer{}),
	Column("b", Integer{}),
	Unique("a", "b"),
)

type edge struct {
	A int64 `db:"a"`
	B int64 `db:"b"`
}

// CallerInfo returns a string containing the file and line number of the
// assert call that failed.
// https://github.com/stretchr/testify/blob/master/assert/assertions.go
// Copyright (c) 2012 - 2013 Mat Ryer and Tyler Bunnell
func CallerInfo() string {
	file := ""
	line := 0
	ok := false

	for i := 2; ; i++ {
		_, file, line, ok = runtime.Caller(i)
		if !ok {
			return ""
		}
		parts := strings.Split(file, "/")
		file = parts[len(parts)-1]

		// TODO Separate this file so break can be called on file name
		// dir := parts[len(parts)-2]
		// if (dir != "assert" && dir != "mock" && dir != "require") || file == "mock_test.go" {
		// 	break
		// }

		break
	}

	return fmt.Sprintf("%s:%d", file, line)
}

// A short test for testing that an SQL statement was compiled as expected
func expectedSQL(t *testing.T, stmt Compiles, expected string, p int) {
	// Get caller information in case of failure
	caller := CallerInfo()

	// Call both Compile and String
	params := Params()
	str := stmt.String()
	compiled, err := stmt.Compile(&defaultDialect{}, params)
	if err != nil {
		t.Error("%s: unexpected error from compile: %s", caller, err)
	}
	if compiled != expected {
		t.Errorf("%s: unexpected SQL: %s != %s", caller, compiled, expected)
	}
	if compiled != str {
		t.Errorf(
			"%s: compile %s should match the default string output %s",
			caller,
			compiled,
			str,
		)
	}
	if params.Len() != p {
		t.Errorf(
			"%s: unexpected number of parameters for %s: %d != %d",
			caller,
			expected,
			params.Len(),
			p,
		)
	}
}

func TestTableSchema(t *testing.T) {
	// Test table properties
	if users.Name != "users" {
		t.Errorf("unexpected Table name: '%s' != 'users'", users.Name)
	}
	if users.String() != "users" {
		t.Errorf("unexpected Table String output: %s != users", users.String())
	}

	// Test the accessor methods
	userId := users.C["id"]
	if userId.name != "id" {
		t.Errorf("Name of returned column was not 'id': '%s'", userId.name)
	}

	// A pointer to the column's table should have been added
	if userId.table != users {
		t.Errorf("Unexpected Table: %+v", userId.table)
	}

	// And primary key(s) should exist
	pk := users.PrimaryKey()
	if len(pk) != 1 && pk[0] != "id" {
		t.Errorf("unexpected primary key")
	}

	// Test improper schemas
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when duplicate columns were created")
			}
		}()

		// A table can't have two columns with the same name
		Table("bad",
			Column("a", String{}),
			Column("a", String{}),
		)
	}()

	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a column without a name was created")
			}
		}()

		// A column must have a name
		Table("bad",
			Column("", String{}),
		)
	}()

	// Can't have primary keys without columns of the same name
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a primary key without a corresponding column was created")
			}
		}()
		Table("bad",
			Column("okay", String{}),
			PrimaryKey("not"),
		)
	}()

	// Can't have unique constraints without columns of the same name
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a unique constraint without a corresponding column was created")
			}
		}()
		Table("bad",
			Column("okay", String{}),
			Unique("not"),
		)
	}()
}

// Test the sql.SelectStmts generated by table.Select() and Select()
func TestTableSelect(t *testing.T) {
	// All three of these select statements should produce the same output
	x := `SELECT "users"."id", "users"."name", "users"."password" FROM "users"`
	expectedSQL(t, users.Select(), x, 0)
	expectedSQL(t, Select(users), x, 0)
	expectedSQL(
		t,
		Select(users.C["id"], users.C["name"], users.C["password"]),
		x,
		0,
	)

	// Select a column that doesn't exist
	stmt := Select(users.C["joined"])
	output, err := stmt.Compile(&defaultDialect{}, Params())
	if err != ErrNilSelect {
		t.Errorf("Improper SELECT should have generated an error")
	}
	if output != "" {
		t.Errorf("Unexpected output from an improper SELECT: %s", output)
	}
}

func TestTableSelectExcept(t *testing.T) {
	x := `SELECT "users"."id", "users"."name" FROM "users"`
	expectedSQL(t, users.SelectExcept(users.C["password"]), x, 0)
	expectedSQL(t, SelectExcept(users, users.C["password"]), x, 0)
}

// Test the InsertStmt generated by table.Insert()
func TestTableInsert(t *testing.T) {
	// An example user
	admin := user{1, "admin", "secret"}

	// Insert a single value into the table
	stmt := users.Insert(&admin)
	expectedSQL(
		t,
		stmt,
		`INSERT INTO "users" ("id", "name", "password") VALUES ($1, $2, $3)`,
		3,
	)
}

// Test DeleteStmt generated by table.Delete()
func TestTableDelete(t *testing.T) {
	// Delete the entire table
	expectedSQL(t, users.Delete(), `DELETE FROM "users"`, 0)

	// Delete using a conditional
	expectedSQL(
		t,
		users.Delete().Where(users.C["id"].Equals(1)),
		`DELETE FROM "users" WHERE "users"."id" = $1`,
		1,
	)
}

// Test UpdateStmt generated by table.Update()
func TestTableUpdate(t *testing.T) {
	expectedSQL(
		t,
		users.Update(Values{"name": "Jabroni"}),
		`UPDATE "users" SET "name" = $1`,
		1,
	)
}
