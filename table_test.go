package aspect

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// TODO Should this be an illegal schema?
var noColumns = Table("none")

var singleColumn = Table("single",
	Column("name", String{}),
)

// Declare schemas that can be used package-wide
var users = Table("users",
	Column("id", Integer{NotNull: true}),
	Column("name", String{Length: 32, Unique: true, NotNull: true}),
	Column("password", String{Length: 128}),
	PrimaryKey("id"),
)

type user struct {
	ID       int64  `db:"id"`
	Name     string `db:"name"`
	Password string `db:"password"`
}

var views = Table("views",
	Column("id", Integer{PrimaryKey: true}),
	Column("user_id", Integer{}),
	Column("url", String{}),
	Column("ip", String{}),
	Column("timestamp", Timestamp{}),
)

var edges = Table("edges",
	Column("a", Integer{}),
	Column("b", Integer{}),
	PrimaryKey("a", "b"),
)

type edge struct {
	A int64 `db:"a"`
	B int64 `db:"b"`
}

var attrs = Table("attrs",
	Column("id", Integer{PrimaryKey: true}),
	Column("a", Integer{}),
	Column("b", Integer{}),
	Unique("a", "b"),
)

func TestTableSchema(t *testing.T) {
	assert := assert.New(t)

	// Test table properties
	assert.Equal("users", users.Name)
	assert.Equal("users", users.String())

	// Test the accessor methods
	userID := users.C["id"]
	assert.Equal("id", userID.name)
	assert.Equal(users, userID.table)

	// And primary key(s) should exist
	assert.Equal(PrimaryKeyArray{"id"}, users.pk)

	// Unique constraints should be declared
	assert.Equal([]UniqueConstraint{{"a", "b"}}, attrs.uniques)

	// Primary keys can also be specified through types
	assert.Equal(PrimaryKeyArray{"id"}, attrs.pk)

	// As well as uniques
	assert.Equal([]UniqueConstraint{{"name"}}, users.uniques)

	// Test improper schemas
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when duplicate columns were created")
			}
		}()

		// A table can't have two columns with the same name
		Table("bad",
			Column("a", String{}),
			Column("a", String{}),
		)
	}()

	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a column without a name was created")
			}
		}()

		// A column must have a name
		Table("bad",
			Column("", String{}),
		)
	}()

	// Can't have primary keys without columns of the same name
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a primary key without a corresponding column was created")
			}
		}()
		Table("bad",
			Column("okay", String{}),
			PrimaryKey("not"),
		)
	}()

	// Can't have unique constraints without columns of the same name
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when a unique constraint without a corresponding column was created")
			}
		}()
		Table("bad",
			Column("okay", String{}),
			Unique("not"),
		)
	}()

	// Can't have multiple primary keys (must use a composite primary key!)
	func() {
		defer func() {
			if panicked := recover(); panicked == nil {
				t.Errorf("table failed to panic when multiple columns were marked as primary keys outside of a composite primary key")
			}
		}()
		Table("bad",
			Column("id", Integer{PrimaryKey: true}),
			Column("id2", Integer{PrimaryKey: true}),
		)
	}()
}

func TestTableSelectExcept(t *testing.T) {
	expect := NewTester(t, &defaultDialect{})

	x := `SELECT "users"."id", "users"."name" FROM "users"`
	expect.SQL(x, users.SelectExcept(users.C["password"]))
	expect.SQL(x, SelectExcept(users, users.C["password"]))
}

// Test the InsertStmt generated by table.Insert()
func TestTableInsert(t *testing.T) {
	expect := NewTester(t, &defaultDialect{})

	// An example user
	admin := user{1, "admin", "secret"}

	// Insert a single value into the table
	expect.SQL(
		`INSERT INTO "users" ("id", "name", "password") VALUES ($1, $2, $3)`,
		users.Insert().Values(&admin),
		1,
		"admin",
		"secret",
	)

	// Test a single column
	expect.SQL(
		`INSERT INTO "single" ("name") VALUES ($1)`,
		singleColumn.Insert().Values(struct{ Name string }{Name: "hello"}),
		"hello",
	)
}

// Test DeleteStmt generated by table.Delete()
func TestTableDelete(t *testing.T) {
	expect := NewTester(t, &defaultDialect{})

	// Delete the entire table
	expect.SQL(`DELETE FROM "users"`, users.Delete())

	// Delete using a conditional
	expect.SQL(
		`DELETE FROM "users" WHERE "users"."id" = $1`,
		users.Delete().Where(users.C["id"].Equals(1)),
		1,
	)
}

// Test UpdateStmt generated by table.Update()
func TestTableUpdate(t *testing.T) {
	expect := NewTester(t, &defaultDialect{})

	expect.SQL(
		`UPDATE "users" SET "name" = $1`,
		users.Update().Values(Values{"name": "Jabroni"}),
		"Jabroni",
	)
}
